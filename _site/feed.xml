<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-05-12T09:28:09+08:00</updated><id>/feed.xml</id><title type="html">Yue Yin’s website</title><subtitle>Stuffs about programming and learning</subtitle><author><name>Yue Yin</name></author><entry><title type="html">[leetcode31] Next Permutation</title><link href="/LeetCode31-next-permutation/" rel="alternate" type="text/html" title="[leetcode31] Next Permutation" /><published>2021-04-27T00:00:00+08:00</published><updated>2021-04-27T00:00:00+08:00</updated><id>/%5BLeetCode31%5D-next-permutation</id><content type="html" xml:base="/LeetCode31-next-permutation/">&lt;h2 id=&quot;problem-next-permutation&quot;&gt;Problem: Next Permutation&lt;/h2&gt;

&lt;p&gt;https://leetcode.com/problems/next-permutation/&lt;/p&gt;

&lt;h2 id=&quot;how-is-a-permutation-generated&quot;&gt;How is a permutation generated?&lt;/h2&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;permute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;backtrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backtrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;backtrack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nums&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backtrack(nums, idx, res)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[:idx]&lt;/code&gt; contains slots whose value have been chosen, while &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[idx:]&lt;/code&gt; contains slots whose value haven’t been chosen. Each value (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[idx]&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[idx+1]&lt;/code&gt;, …, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[nums.size()-1]&lt;/code&gt;) are swapped to position &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;idx&lt;/code&gt;, and then the suffix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[idx+1:]&lt;/code&gt; is permutated by calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backtrack&lt;/code&gt; recursively.&lt;/p&gt;

&lt;h2 id=&quot;lexical-order&quot;&gt;Lexical order&lt;/h2&gt;

&lt;p&gt;For numbers, lexical order is the same as ascending order. To generate permutations in lexical order for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums&lt;/code&gt;, sort it, then call the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;permute&lt;/code&gt; function above.&lt;/p&gt;

&lt;p&gt;We can observe that the last permutation in lexical order is the array in descending order. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[3,2,1]&lt;/code&gt; is the last permutation for array &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1,2,3]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can also observe the following: when calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backtrack(nums, idx+1, res)&lt;/code&gt; to permutate the suffix, this recursive call returns after generating the last permutation for subarray &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[idx+1:]&lt;/code&gt;. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backtrack([3,1,2], 1, res)&lt;/code&gt; returns after generating &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1,2]&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[2,1]&lt;/code&gt;. As explained, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[2,1]&lt;/code&gt; is in descending order. Note that a single-element subarray can be considered as a specical case of descending subarray.&lt;/p&gt;

&lt;h2 id=&quot;next-permutation-in-lexical-order&quot;&gt;Next permutation in lexical order&lt;/h2&gt;

&lt;p&gt;Based on the observation above, we can see:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Each permutation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[0:]&lt;/code&gt; generates all permutations for a suffix &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i:]&lt;/code&gt;, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i &amp;gt;= 0&lt;/code&gt;. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1,2,3]&lt;/code&gt; finishes all permutations for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[2:]&lt;/code&gt;; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1,3,2]&lt;/code&gt; finishes all permutations for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[1:]&lt;/code&gt;. This is the same as the return of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backtrack(nums, i, res)&lt;/code&gt;. The value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; can be determined by searching for the leftmost index of a descending suffix.&lt;/li&gt;
  &lt;li&gt;After &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backtrack(nums, i, res)&lt;/code&gt; returns, you should pick a new element at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i-1]&lt;/code&gt;. To do so, pick the smallest value in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i:]&lt;/code&gt; that’s greater than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i-1]&lt;/code&gt;. The reason is that, when generating ALL permutations in lexical order, we sort the array before calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;permutate&lt;/code&gt;. Thus, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i:]&lt;/code&gt; are swapping to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i]&lt;/code&gt; one by one, in sorted order.&lt;/li&gt;
  &lt;li&gt;After swapping the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i-1]&lt;/code&gt;, you need to have sort &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i:]&lt;/code&gt;, as the first permutation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i:]&lt;/code&gt; must be in ascending order. Just after swap, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nums[i:]&lt;/code&gt; is in descending order. Thus, you just need to reverse the array.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[6, 2, 1, 5, 4, 3, 0]
       ^  &amp;lt;--------&amp;gt;

[6, 2, 3, 5, 4, 1, 0]
       ^  &amp;lt;--------&amp;gt;
       
[6, 2, 3, 0, 1, 4, 5]
       ^  &amp;lt;--------&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;https://www.youtube.com/watch?v=quAS1iydq7U&lt;/p&gt;</content><author><name>Yue Yin</name></author><summary type="html">Problem: Next Permutation https://leetcode.com/problems/next-permutation/ How is a permutation generated? class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; backtrack(nums, 0, res); return res; } void backtrack(vector&amp;lt;int&amp;gt;&amp;amp; nums, int idx, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; res) { if (idx == nums.size()) res.push_back(nums); for (int i = idx; i &amp;lt; nums.size(); ++i) { swap(nums[idx], nums[i]); backtrack(nums, idx+1, res); swap(nums[idx], nums[i]); } } }; When calling backtrack(nums, idx, res), nums[:idx] contains slots whose value have been chosen, while nums[idx:] contains slots whose value haven’t been chosen. Each value (nums[idx], nums[idx+1], …, nums[nums.size()-1]) are swapped to position idx, and then the suffix nums[idx+1:] is permutated by calling backtrack recursively. Lexical order For numbers, lexical order is the same as ascending order. To generate permutations in lexical order for nums, sort it, then call the permute function above. We can observe that the last permutation in lexical order is the array in descending order. For example, [3,2,1] is the last permutation for array [1,2,3]. We can also observe the following: when calling backtrack(nums, idx+1, res) to permutate the suffix, this recursive call returns after generating the last permutation for subarray nums[idx+1:]. For example, backtrack([3,1,2], 1, res) returns after generating [1,2] and [2,1]. As explained, [2,1] is in descending order. Note that a single-element subarray can be considered as a specical case of descending subarray. Next permutation in lexical order Based on the observation above, we can see: Each permutation of nums[0:] generates all permutations for a suffix nums[i:], where i &amp;gt;= 0. For example, [1,2,3] finishes all permutations for nums[2:]; [1,3,2] finishes all permutations for nums[1:]. This is the same as the return of backtrack(nums, i, res). The value of i can be determined by searching for the leftmost index of a descending suffix. After backtrack(nums, i, res) returns, you should pick a new element at nums[i-1]. To do so, pick the smallest value in nums[i:] that’s greater than nums[i-1]. The reason is that, when generating ALL permutations in lexical order, we sort the array before calling permutate. Thus, nums[i:] are swapping to nums[i] one by one, in sorted order. After swapping the value of nums[i-1], you need to have sort nums[i:], as the first permutation of nums[i:] must be in ascending order. Just after swap, nums[i:] is in descending order. Thus, you just need to reverse the array. Example: [6, 2, 1, 5, 4, 3, 0] ^ &amp;lt;--------&amp;gt; [6, 2, 3, 5, 4, 1, 0] ^ &amp;lt;--------&amp;gt; [6, 2, 3, 0, 1, 4, 5] ^ &amp;lt;--------&amp;gt; Reference https://www.youtube.com/watch?v=quAS1iydq7U</summary></entry><entry><title type="html">[5.3] Query Optimization</title><link href="/database/5.3-query-optimization/" rel="alternate" type="text/html" title="[5.3] Query Optimization" /><published>2021-04-23T00:00:00+08:00</published><updated>2021-04-23T00:00:00+08:00</updated><id>/database/%5B5.3%5D-query-optimization</id><content type="html" xml:base="/database/5.3-query-optimization/">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Because SQL is declarative, the query only tells the DBMS what to compute, but not how to compute it. The DBMS needs to translate the query into an executable query plan. The job of the DBMS’s optimizer is to pick an optimial plan for a given query.&lt;/p&gt;

&lt;p&gt;There are two types of optimization strategies: (1) heuristics: match query to known patterns. This approach may require consulting the system catalog, but never need to examine the data itself; (2) cost estimation: read the data and estimate the cost of executing equivalent plans. Pick the one with the lowest cost.&lt;/p&gt;

&lt;h2 id=&quot;logical-plan-and-physical-plan&quot;&gt;Logical Plan and Physical Plan&lt;/h2&gt;

&lt;p&gt;The optimizer generates a mapping from a &lt;em&gt;logical algebra expression&lt;/em&gt; to the optimal equivalent &lt;em&gt;physical algebra expression&lt;/em&gt;. The logical plan is roughly equivalent to the relational algebra expression in the query. &lt;em&gt;Physical operators&lt;/em&gt; define a specific execution strategy using an access path for the different operators in the query plan. There does not always exists a one-to-one mapping from logical to physical plan.&lt;/p&gt;

&lt;p&gt;Many query optimization relies on relational algebra equivalence.&lt;/p&gt;

&lt;h2 id=&quot;cost-estimations&quot;&gt;Cost Estimations&lt;/h2&gt;

&lt;p&gt;The cost of a query plan depends on CPU, disk I/O, memory, network, etc. Exhaustive enumeration of all possible plans for a query is too expensive. To approximate the cost, DBMS’s maintain internal statistics about tables, attributes, and indexes in the system catalog.&lt;/p&gt;

&lt;p&gt;For each relation $ R $, the DBMS maintains:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$ N_R $: the number of tuples in $ R $&lt;/li&gt;
  &lt;li&gt;$ V(A, R) $: the number of distinct values of attribute $ A $&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Techniques include: histogram, sampling.&lt;/p&gt;

&lt;h2 id=&quot;plan-enumeration&quot;&gt;Plan enumeration&lt;/h2&gt;

&lt;p&gt;For single-query query plans, the hardest task is to choose the best access methods. Normally heuristics rules are used.&lt;/p&gt;

&lt;p&gt;For multi-relation query plans, the number of alternative plans grows rapidly as the number of joins increases. IBM System R only consider left-deep join trees, as they are better suited for the iterator model - the DBMS does not need to materialize the outputs of the join operators.&lt;/p&gt;

&lt;p&gt;To make query plans, the DBMS must enumerate the orderings, then the plans for each operator, then the access methods for each table. Dynamci programming can be used.&lt;/p&gt;</content><author><name>Yue Yin</name></author><category term="Database" /><summary type="html">Overview</summary></entry><entry><title type="html">[5.4] Concurrency Control</title><link href="/database/5.4-concurrency-control/" rel="alternate" type="text/html" title="[5.4] Concurrency Control" /><published>2021-04-23T00:00:00+08:00</published><updated>2021-04-23T00:00:00+08:00</updated><id>/database/%5B5.4%5D-concurrency-control</id><content type="html" xml:base="/database/5.4-concurrency-control/">&lt;h2 id=&quot;transactions&quot;&gt;Transactions&lt;/h2&gt;

&lt;p&gt;Goal: correctness + efficiency.&lt;/p&gt;

&lt;p&gt;ACID:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atomicity: either all actions in the transaction happen, or none happen&lt;/li&gt;
  &lt;li&gt;consistency: if the transaction is consistent and the database is consistent at the beginning of the transaction, then the database is guaranteed to be consistent when the transaction completes.&lt;/li&gt;
  &lt;li&gt;isolation: when a transaction executes, it should have the illusion that it is isolated from other transactions.&lt;/li&gt;
  &lt;li&gt;durability: if a transaction commits, its effect on the database should persist.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;atomicity&quot;&gt;Atomicity&lt;/h3&gt;

&lt;p&gt;There are two approaches: Logging, and Shadow Paging.&lt;/p&gt;

&lt;p&gt;In logging, the DBMS logs all actions so that it can undo the actions of aborted transactions. Most widely used.&lt;/p&gt;

&lt;p&gt;In shadow paging, the DBMS makes copies of pages modified by the transactions and transactions make changes to those copies.Only when the transaction commits is the page made available. Compared with logging, this is slower at runtime but faster at recovery.&lt;/p&gt;

&lt;h3 id=&quot;consistency&quot;&gt;Consistency&lt;/h3&gt;

&lt;p&gt;Logical correctness of the database.&lt;/p&gt;

&lt;h3 id=&quot;isolation&quot;&gt;Isolation&lt;/h3&gt;

&lt;p&gt;The DBMS provides the illusion that they are running alone in the system, and do not see the effects of concurrent transactions. This is &lt;strong&gt;equivalent&lt;/strong&gt; to a system where transaction execute in &lt;strong&gt;serial order&lt;/strong&gt; but with better performance. The DBMS must interleave the operations of concurrent transactions while maintaining the illusion of isolation.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;concurrency control protocol&lt;/em&gt; is how the DBMS decides the proper interleaving of operations in concurrent transactions at runtime. There are two categories of concurrency control protocols: &lt;strong&gt;pessimistic&lt;/strong&gt; and &lt;strong&gt;optimistic&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The order in which the DBMS executes operations is called &lt;em&gt;execution schedule&lt;/em&gt;. The goal of concurrency control protocol is to generate an execution schedule equivalent to some serial execution:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Serial schedule: no interleaving happens.&lt;/li&gt;
  &lt;li&gt;Equivalent schedule: two schedules are equivalent if the effect of executing the first schedule is identical to the effect of executing the second schedule, for any database state.&lt;/li&gt;
  &lt;li&gt;Serializable schedule: a serializable schedule is a schedule equivalent to any serial schedule.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &lt;em&gt;conflict&lt;/em&gt; between two operations occur if the operations are from different transactions, being performed on the same object, and at least one of them is a write. There are three types of conflicts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Read-write conflicts (unrepeatable read): a transaction see different values when reading an object multiplt times.&lt;/li&gt;
  &lt;li&gt;Write-read conflicts (dirty read): a transaction sees the write effects of an uncommitted transaction&lt;/li&gt;
  &lt;li&gt;Write-write conflict (lost update): a transaction overwrites the uncommited writes by another concurrent transaction.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DBMS typically supports &lt;em&gt;conflict serializability&lt;/em&gt;. Two schedules are &lt;em&gt;conflict equivalent&lt;/em&gt; is they involve the same operations of the same transactions, and every pair of conflicting operations is ordered in the same way in both schedules. A schedule is &lt;em&gt;conflict serializable&lt;/em&gt; if it is conflict equivalent to some serial schedule.&lt;/p&gt;

&lt;p&gt;One can verify that a schedule is conflict serializable by swapping non-conflict operations until a serial schedule is formed. For schdules with many transactions, this can be expensive. A better way is to use a &lt;em&gt;dependency graph&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In a dependency graph, each transaction is a node. A directed edge from node T1 to node T2 exists if and only if an operation O1 in N1 conflicts with an operation O2 in N2, and O1 occurs before O2 in the schedule. The schedule is conflict serializable if the dependency graph is acyclic.&lt;/p&gt;

&lt;h3 id=&quot;durability&quot;&gt;Durability&lt;/h3&gt;

&lt;p&gt;All changes of committed transactions must be durable, even after a crash or restart. Method: logging, shadow paging.&lt;/p&gt;

&lt;h2 id=&quot;two-phase-locking-2pl&quot;&gt;Two-Phase Locking (2PL)&lt;/h2&gt;

&lt;p&gt;A dependency graph tells you if a existing schedule is serializable, but cannot generate the schdule for you at runtime. A DBMS can use locks to dynamically generate serializable schedule for transactions at runtime. A centralized transaction manager maintains a lock table to decide whether a transaction can acquire a lock or not. The lock table doesn’t need to be durable as any active transaction when the DBMS crashes is automatically aborted.&lt;/p&gt;

&lt;p&gt;Two-phase locking (2PL) is a pessimistic concurrency control protocol. In the growing phase, a transaction acquires locks. The transaction enters the shrinking phase immediately after it releases the first lock. The transaction cannot acquire locks any more in the shrinking phase.&lt;/p&gt;

&lt;p&gt;A schedule is &lt;em&gt;strict&lt;/em&gt; if any value written by a transaction is not read/overwritten by another transaction until the first transaction commits. &lt;em&gt;Strict 2PL&lt;/em&gt; only releases locks on commit. The advantage strict 2PL is that it doesn’t incur cascading aborts. The disadvantage is that it limits concurrency even more.&lt;/p&gt;

&lt;h3 id=&quot;deadlock-handling&quot;&gt;Deadlock Handling&lt;/h3&gt;

&lt;p&gt;There are two appraches to handle deadlocks: detection and prevention.&lt;/p&gt;

&lt;p&gt;In &lt;em&gt;deadlock detection&lt;/em&gt;, the DBMS creates a waits-for graph where transactions are nodes and there exists a directed edge from Ti to Tj if transaction Ti is waiting for transaction Tj to release a lock. The DBMS can launch a background thread to periodically check for cycles in the waits-for graph and break the cycles by selecting “victim” transaction(s) to abort. The victim transaction will either restart or abort depending on the application. Multiple transaction properties can be considered when selecting a victim.&lt;/p&gt;

&lt;p&gt;Instead of letting transactons to acquire any lock they need and deal with deadlocks afterwards, &lt;em&gt;deadlock prevention&lt;/em&gt; 2PL stops transactions from causing deadlocks before they occur. When a transaction tries to acquire a lock held by another transaction (which could cause a deadlock), the DBMS kills one of them. To implement this, transactions are assigned priorities based on timestamps (older transactions have higher priority). The schems guarantee no deadlocks as only one direction is allowed when waiting for a lock. When a transaction restarts, it uses the &lt;strong&gt;&lt;em&gt;original&lt;/em&gt;&lt;/strong&gt; timestamp, to avoid starvation.&lt;/p&gt;

&lt;h3 id=&quot;lock-granularity&quot;&gt;Lock granularity&lt;/h3&gt;

&lt;p&gt;Tuple-level lock is very expensive. Hierarchical locking reduces the overhead. For example, a lock on the table is much cheaper than locking all tuples in the table. &lt;strong&gt;Intention locks&lt;/strong&gt; allow a higher level node to be locked in shared/exclusive mode without checking all decendant nodes.&lt;/p&gt;

&lt;h2 id=&quot;timestamp-ordering&quot;&gt;Timestamp Ordering&lt;/h2&gt;

&lt;p&gt;Timestamp ordering (T/O) is a class of optimistic concurrency control protocols. Two properties:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Each transacton Ti is assigned a &lt;em&gt;unique&lt;/em&gt;, &lt;em&gt;fixed&lt;/em&gt; timestamp that’s monotonically increasing.&lt;/li&gt;
  &lt;li&gt;If TS(Ti) &amp;lt; TS(Tj), the execution schedule is equivalent to a serial schedule where Ti appears before Tj.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To allocate timestamps, you can use system clock, but with edge cases like daylight savings. You can also use logical counter, but must deal with overflows. Some systems use hybrid approach. Also, maintaining the timestamp across a distributed system is hard.&lt;/p&gt;

&lt;h3 id=&quot;basic-to&quot;&gt;Basic T/O&lt;/h3&gt;

&lt;p&gt;No locks are used. Every database object X is tagged with a timestamp of the last transaction that successfully perform a read (R-TS(X)) or write (W-TS(X)). The DBMS checks the timestamp for every operation. If a transaction tries to access an object in a way that violates the timestamp ordering, the transaction is aborted and restarted.&lt;/p&gt;

&lt;p&gt;For read, the ordering is violated if TS(Ti) &amp;lt; W-TS(X), so Ti is restarted with a new timestamp. Otherwise, the read is performed and R-TS(X) is updated to be max{R-TS(X), TS(Ti)}. It makes a local copy of X to ensure repeatable read.&lt;/p&gt;

&lt;p&gt;For write, if TS(Ti) &amp;lt; R-TS(X) or TS(Ti) &amp;lt; W-TS(X), Ti must be restarted with a new timestamp. Otherwise, the write is performed and W-TS(X) is updated to be TS(Ti). It makes a local copy of X to ensure repeatable read.&lt;/p&gt;

&lt;p&gt;Possible problems: (1) high overhead from making copies for repeatable read; (2) long running transactions can get starved; (3) suffers from timestamp allocation bottleneck on highly concurrent system.&lt;/p&gt;

&lt;h3 id=&quot;optimistic-concurrency-control-occ&quot;&gt;Optimistic Concurrency Control (OCC)&lt;/h3&gt;

&lt;p&gt;Optimistic concurrency control (OCC) is another optimistic concurrency control protocol that uses timestamps. In OCC, a &lt;em&gt;private workspace&lt;/em&gt; is created for each transaction. Any object read is copied into the workspace, and any object written is copied into the workspace and modified there. No other transactions can read the changes made by a transaction in its private workspace.&lt;/p&gt;

&lt;p&gt;When a transaction commits, the DBMS compares the transaction’s workspace &lt;em&gt;write set&lt;/em&gt; to see whether it conflicts with other transactions. If there’s no conflicts, the write set is installed into the “global” database. OCC consists of 3 phases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Work phase: the DBMS tracks read/write sets of transactions and store writes in a private workspace;&lt;/li&gt;
  &lt;li&gt;Validation phase: before a transaction commits, the DBMS checks if it conflicts with other transactions.&lt;/li&gt;
  &lt;li&gt;Write phase: if validation succeeds, apply the private workspace changes to the database. Otherwise, restart txn.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The DBMS assigns transaction timestamps when they enter the validation phase. Transaction that havn’t entered the validation phase are assigned a timestamp of infinity. To ensure serializable schedule, the DBMS checks Ti against other transactions for RW or WW conflicts and makes sure that all conflict are in one direction (e.g older -&amp;gt; younger). There’re two methods for this phase: backward validation, and forward validation. Backward validation checks if the read/write set of commiting transaction intersects with those of the committed ones. Forward validation checks if the read/write set of commiting transaction intersects with those not yet committed.&lt;/p&gt;

&lt;p&gt;If TS(Ti) &amp;lt; TS(Tj), then one of the following three conditions must hold to pass the validation phase:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ti completes all three phases before Tj begins;&lt;/li&gt;
  &lt;li&gt;Ti completes before Tj starts its write phase, and Ti does not write to any object read by Tj (Suppose Ti doesn’t abort and its write set intersects with Tj, Tj’s write could depend on the stale value, and later overwrites the value written by Ti. This is incorrect - a transaction with larger timestamp should not miss the writes by another transaction with lower timestamp);&lt;/li&gt;
  &lt;li&gt;Ti completes Work phase before Tj completes its Work phase, and Ti doesn’t write to any object read/written by Tj.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Possible problems: (1) high overhead for copying data locally into private workspace; (2) validation/write phase bottleneck (latching needed to avoid data race); (3) aborts are wasteful; (4) timestamp allocation bottleneck.&lt;/p&gt;

&lt;h2 id=&quot;ioslation-levels&quot;&gt;Ioslation Levels&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Isolation levels&lt;/th&gt;
      &lt;th&gt;Behavior&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;read uncommitted&lt;/td&gt;
      &lt;td&gt;all anomalies&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read committed&lt;/td&gt;
      &lt;td&gt;no dirty read&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;repeatable read (snapshot isolation)&lt;/td&gt;
      &lt;td&gt;no dirty read, no unrepeatable read&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;serializable&lt;/td&gt;
      &lt;td&gt;no dirty read, no unrepeatable read, no phantom&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;How to avoid phantom read? What’s the difference from nonrepeatable read?: https://stackoverflow.com/a/23138849.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Serializable isolation must prevent phantoms. 2PL implements this with the predicate lock, which doesn’t belong to a particular object/row, but belongs to all objects that match some search conditions (a predicate).&lt;/p&gt;

  &lt;p&gt;Predicate locks don’t work well practically, as checking for matching locks can be expensive. Index-range locking is a simplified approaximation of predicate locking. An approximation of predicate is attached to one of the indexes. If no suitable index to attach the lock, the database can fallback to a shared lock on the entire table.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    Implementation
Serializable         strict 2PL; index lock;
Repeatable read      strict 2PL (S-locks released on commit/abort)
Read committed       strict 2PL; acquiring/releasing S-locks doesn't affect growing/shrinking phase, and S-locks are
                     immediately released after each read (and re-acquired later if needs to read).
Read uncommitted     strict 2PL; not acquiring S-locks for read
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;multi-version-concurrency-control&quot;&gt;Multi-Version Concurrency Control&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;MVCC is the most widely used scheme in DBMS&lt;/strong&gt;, it’s more than a concurrency control protocol. It’s mainly about determining the visibility of writes to transactions.&lt;/p&gt;

&lt;p&gt;With MVCC, the DBMS mtaintains multiple &lt;strong&gt;physical&lt;/strong&gt; version of a single &lt;strong&gt;logical&lt;/strong&gt; object. When a transaction writes to an object, the DBMS creates a new version of that object. When a transaction reads an object, it reads the newest version that existed when the transaction started. It won’t see any writes that are not committed yet when the transaction starts. For detailed explanation of MVCC execution and the usage of transaction status table, refer to Lecture 19 slides.&lt;/p&gt;

&lt;p&gt;The fundamental concept/benefit of MVCC is that writes do not block writers, and readers do not block writers. This means one transaction can modify an object while other transactions read old versions. Also, read-only transactions can read a consistent snapshot of the database without using any locks.&lt;/p&gt;

&lt;p&gt;There are four important MVCC design decisions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Concurrency Control Protocol&lt;/li&gt;
  &lt;li&gt;Version Storage&lt;/li&gt;
  &lt;li&gt;Garbage Collection&lt;/li&gt;
  &lt;li&gt;Index Management&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;concurrency-control-protocol&quot;&gt;Concurrency Control Protocol&lt;/h3&gt;

&lt;p&gt;For concurrency control protocl, you can choose among 2PL, T/O and OCC.&lt;/p&gt;

&lt;h3 id=&quot;version-storage&quot;&gt;Version Storage&lt;/h3&gt;

&lt;p&gt;Version storage is about how the DBMS stores different physical versions of a logical object and how transactions find the newest version visible to them. The DBMS uses the tuple’s pointer field to create a &lt;em&gt;version chain&lt;/em&gt; per logical tuple, which is a linked list of versions sorted by timestamp. Indexes alwasy point to the “head” of the chain, which is either the newest or oldest version depending on implementation. A thread traverses the chain until it finds the correct version.&lt;/p&gt;

&lt;p&gt;Different storage schemes determine where/what to store for each version:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Append-only storage&lt;/strong&gt;. All physical versions of a logical tuple are stored in the same table space. Versions are mixed together in the table and each update appends a new version of the tuple into the table, and updates the version chain.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/home/yy0125/.config/Typora/typora-user-images/image-20210423132114894.png&quot; alt=&quot;image-20210423132114894&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Time-travel storage&lt;/strong&gt;. The DBMS maintains a sperate table called the time-travel table to store older versions of the tuple. On every update, the DBMS copies the old version of the tuple to the time-travel table, and overwrites the tuple in the main table with the new data. Pointers of the tuple in the main table point to old versions in the time-travel table.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/home/yy0125/.config/Typora/typora-user-images/image-20210423132342010.png&quot; alt=&quot;image-20210423132342010&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Delta storage&lt;/strong&gt;. Delta storage uses a separate table similar to time-travel storage, but only stores the deltas (changes between tuples). Transactions can recreate older versions by iterating through the deltas. This has faster write than time-travel storage, but slower reads.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;garbage-collection&quot;&gt;Garbage collection&lt;/h3&gt;

&lt;p&gt;The DBMS remove &lt;em&gt;reclaimable&lt;/em&gt; physical versions from the database over time. A version is reclaimable if no active transaction can see that version, or if it was created by an aborted transaction.&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;tuple-level GC&lt;/em&gt;, the DBMS finds old versions by scanning tuples directly. This can be done by a background thread periodically, A simple optimization is to maintain a “dirty page bitmap”, which keeps track of the pages that have been modified since previous scan. This help the thread to skip pages that havn’t changed. Another approach is for worker threads to identify reclaimable versions as they traverse the version chain.&lt;/p&gt;

&lt;p&gt;For &lt;em&gt;transaction-level GC&lt;/em&gt;, each transaction is responsible for tracking their own old versions so that DBMS doesn’t have to scan tuples. Each transaction maintains its own read/write set. When it commits/aborts, the DBMS can use that to identify which tuples to reclaim.&lt;/p&gt;

&lt;h3 id=&quot;index-management&quot;&gt;Index Management&lt;/h3&gt;

&lt;p&gt;All primary key indexes always point to the version chain head.&lt;/p&gt;</content><author><name>Yue Yin</name></author><category term="Database" /><summary type="html">Transactions</summary></entry><entry><title type="html">Terminate Condition</title><link href="/leetcode/terminate-condition/" rel="alternate" type="text/html" title="Terminate Condition" /><published>2021-04-23T00:00:00+08:00</published><updated>2021-04-23T00:00:00+08:00</updated><id>/leetcode/terminate-condition</id><content type="html" xml:base="/leetcode/terminate-condition/">&lt;p&gt;This post is about the terminate conditions when solving algorithm problems.&lt;/p&gt;

&lt;h2 id=&quot;binary-search&quot;&gt;Binary Search&lt;/h2&gt;

&lt;p&gt;The idea of binary search is simple, but there are two variants of implementation.&lt;/p&gt;

&lt;h3 id=&quot;variant-1&quot;&gt;Variant 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (l &amp;lt; r) {
	int m = l + (r - l) / 2;
	if (...) {
		l = m-1;
	} else {
		r = m;	
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First, you should never use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l = m&lt;/code&gt;. When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l + 1 &amp;gt;= m&lt;/code&gt;, this causes infinite loop. Thus, we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l = m-1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r = m&lt;/code&gt;. However, even with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r = m&lt;/code&gt;, you should avoid having &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l == r&lt;/code&gt;, which cause infinite lsoop again. Conclusion: when using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r=m&lt;/code&gt;, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l &amp;lt; r&lt;/code&gt; to avoid infinite loop.&lt;/p&gt;

&lt;h3 id=&quot;variant-2&quot;&gt;Variant 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (l &amp;lt;= r) {
	int m = l + (r - l) / 2;
	if (...) {
		l = m-1;
	} else {
		r = m+1;	
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l = m-1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r = m+1&lt;/code&gt;, no infinite loop is possible, so you can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l &amp;lt;= r&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As we are using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l &amp;lt; r&lt;/code&gt;, when the loop terminates, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l == r&lt;/code&gt;. Suppose &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; are initialized to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; respectively, then the final value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; is in range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[L, R]&lt;/code&gt;. You might need to check whether the target is indeed in the range or not.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&lt;/li&gt;
  &lt;li&gt;https://leetcode-cn.com/problems/sqrtx/&lt;/li&gt;
  &lt;li&gt;https://leetcode-cn.com/problems/binary-search/&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;two-pointers&quot;&gt;Two pointers&lt;/h2&gt;

&lt;p&gt;Should you use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l &amp;lt; r&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l &amp;lt;= r&lt;/code&gt;? Answer: if you want &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; to execute for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l == r&lt;/code&gt;, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l &amp;lt;= r&lt;/code&gt;. Otherwise, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l &amp;lt; r&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (l &amp;lt; r) {
   // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://leetcode-cn.com/problems/remove-element/submissions/&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Yue Yin</name></author><category term="LeetCode" /><summary type="html">This post is about the terminate conditions when solving algorithm problems. Binary Search The idea of binary search is simple, but there are two variants of implementation. Variant 1 while (l &amp;lt; r) { int m = l + (r - l) / 2; if (...) { l = m-1; } else { r = m; } } First, you should never use l = m. When l + 1 &amp;gt;= m, this causes infinite loop. Thus, we use l = m-1 and r = m. However, even with r = m, you should avoid having l == r, which cause infinite lsoop again. Conclusion: when using r=m, use l &amp;lt; r to avoid infinite loop. Variant 2 while (l &amp;lt;= r) { int m = l + (r - l) / 2; if (...) { l = m-1; } else { r = m+1; } } For l = m-1 and r = m+1, no infinite loop is possible, so you can use l &amp;lt;= r. As we are using l &amp;lt; r, when the loop terminates, l == r. Suppose l and r are initialized to L and R respectively, then the final value of l/r is in range [L, R]. You might need to check whether the target is indeed in the range or not. Example: https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ https://leetcode-cn.com/problems/sqrtx/ https://leetcode-cn.com/problems/binary-search/ Two pointers Should you use l &amp;lt; r or l &amp;lt;= r? Answer: if you want while to execute for l == r, use l &amp;lt;= r. Otherwise, use l &amp;lt; r. while (l &amp;lt; r) { // ... } Example: https://leetcode-cn.com/problems/remove-element/submissions/</summary></entry><entry><title type="html">Container With Most Water</title><link href="/container-with-most-water/" rel="alternate" type="text/html" title="Container With Most Water" /><published>2021-04-22T00:00:00+08:00</published><updated>2021-04-22T00:00:00+08:00</updated><id>/container-with-most-water</id><content type="html" xml:base="/container-with-most-water/">&lt;p&gt;https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量(而当前的数值已经记录下来了，因此不论如何移动右指针也没有用)。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;双指针的本质依然是要考虑&lt;strong&gt;所有的情况&lt;/strong&gt;，当某种情况不可能成为最终结果的时候，才移动指针。&lt;/p&gt;</content><author><name>Yue Yin</name></author><summary type="html">https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/ 即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量(而当前的数值已经记录下来了，因此不论如何移动右指针也没有用)。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置。 双指针的本质依然是要考虑所有的情况，当某种情况不可能成为最终结果的时候，才移动指针。</summary></entry><entry><title type="html">[3] User Environment &amp;amp; Protected Control Transfer</title><link href="/os/3-user-environment-&-protected-control-transfer/" rel="alternate" type="text/html" title="[3] User Environment &amp;amp; Protected Control Transfer" /><published>2021-04-20T00:00:00+08:00</published><updated>2021-04-20T00:00:00+08:00</updated><id>/os/%5B3%5D-user-environment-&amp;-protected-control-transfer</id><content type="html" xml:base="/os/3-user-environment-&amp;-protected-control-transfer/">&lt;blockquote&gt;
  &lt;p&gt;Note: this post is largely based on MIT 6.828 Lab3. Thus, we use the term “user environment” instead of the more traditional term “process”. The two are conceptually the same, but differs in interfaces and semantics.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;user-environment-basics&quot;&gt;User Environment Basics&lt;/h2&gt;

&lt;p&gt;The kernel keeps track of user environments with three data structures: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct Env *envs&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct Env *env_free_list&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct Env* curenv&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;envs&lt;/code&gt; is allocated at boot time, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_free_list&lt;/code&gt; is initialized based on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;envs&lt;/code&gt;. Environment state:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Env&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Trapframe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_tf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Saved registers when being descheduled&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Env&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_link&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// Next free Env&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// Unique environment identifier of the env using this `struct Env`&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;envid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_parent_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// env_id of this env's parent&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EnvType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// Indicates special system environments&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Status of the environment&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env_runs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// Number of times environment has run&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// Address space&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env_pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// Kernel virtual address of page dir&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To run a environment, the kernel need logic+data. Logic is primarily defined by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_tf&lt;/code&gt;, containing %esp, %eip, etc. Data is defined by the page directory and page tables.&lt;/p&gt;

&lt;p&gt;To create and run an evironment, call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_create&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_run&lt;/code&gt;. Pseudo-code:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;env_alloc() {
    env = find from free list;
    initialize env;
}

env_setup_vm(e) {
    e-&amp;gt;env_pgdir = page_alloc(); // allocate page directory
    e-&amp;gt;env_pgdir = memcpy(kern_pgdir); // copy from kernel's page directory
}

load_icode(e) {
    switch from kern_pgdir to e-&amp;gt;env_pgdir;
    load program data into e's address space using memset, memcpy;
    switch from e-&amp;gt;env_pgdir to kern_pgdir;
    allocate user stack for e;
    set up e-&amp;gt;env_tf;
}

env_create() {
    e = env_alloc();
    env_setup_vm(e);
    load_icode(e);
}

env_pop_tf(e) {
    pop e-&amp;gt;env_tf into registers;
}

env_run(e) {
    switch from kern_pgdir to e-&amp;gt;env_pgdir;
    env_pop_tf(e);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;protected-control-transfer&quot;&gt;Protected Control Transfer&lt;/h2&gt;

&lt;p&gt;Exceptions and interrupts are both &lt;em&gt;protected control transfers&lt;/em&gt;, causing CPU to switch from user mode (CPL=3) to kernel mode (CPL=0), without giving the user-mode code any opportunity to interfere the kernel or other environments.&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;interrupt&lt;/em&gt; is caused by asynchronous event, like I/O activities. An &lt;em&gt;exception&lt;/em&gt; is caused synchronously by currently running code, like division by zero and invalid memory access. Each interrupt/exception is identified by a number in 0-255 (called &lt;em&gt;vector&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;To ensure protection, entry-points to the kernel are strictly limited. On x86, two mechanisms work together:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When interrupt/exception happens, the CPU uses the vector as an index into the &lt;em&gt;interrupt descriptor table&lt;/em&gt; (IDT), which was set up in the kernel-private memory. From the IDT entry, the CPU loads %eip (instruction pointer) and %cs (code segment), and starts executing in kernel mode.&lt;/li&gt;
  &lt;li&gt;The CPU needs to save the &lt;em&gt;old&lt;/em&gt; processor state before the interrupt/exception occurred, for future resumption. This place must be protected from the user-mode code and the &lt;em&gt;kernel stack&lt;/em&gt; can be used. When the interrupt/exception cause a privilege change from user the kernel mode, the CPU reads the kernel stack location (segment selector and address) from the &lt;em&gt;task state segment&lt;/em&gt; (TSS). The CPU pushes %ss, %esp, %eflags, %cs, %esp and an optional error code to the kernel stack. Then it loads %cs and %esp from the IDT entry, and sets %ss and %esp to refer to the kernel stack. When an interrupt/exception happens in kernel mode, no stack-switching happens. The CPU just pushes %eflags, %cs, %esp, and an optional error code. This supports nested exception.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The kernel should set up the IDT at boot time. Let’s review the responsibility of software and hardware. When an interrupt/exception happens:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The hardware reads from TSS to know the position of the kernel stack;&lt;/li&gt;
  &lt;li&gt;The hardware saves %ss, %esp, %cs, %eip, and possibly an error code to the kernel stack, and updates %ss and %esp to refer to the kernel stack. This constructs part of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct Trapframe&lt;/code&gt;. Hardware finishes all its jobs, and software takes over.&lt;/li&gt;
  &lt;li&gt;Control passes to the entry point in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trapentry.S&lt;/code&gt;, pushes other registers onto the kernel stack to complete the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct Trapframe&lt;/code&gt;. Then calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trap&lt;/code&gt;, with the trapframe as an argument, in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_alltraps&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trap&lt;/code&gt; function in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trap.c&lt;/code&gt; executes.&lt;/li&gt;
  &lt;li&gt;In JOS, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trap&lt;/code&gt; calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trap_dispatch&lt;/code&gt; to dispatch to specific handler. After that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trap&lt;/code&gt; calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_run&lt;/code&gt; to pop registers and fall back into user mode.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;exception-handling&quot;&gt;Exception Handling&lt;/h2&gt;

&lt;p&gt;System calls can be implemented with protected control transfer. The application pass the system call number and arguments in registers, then calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int $0x30&lt;/code&gt;. The kernel passes the return value in %eax.&lt;/p&gt;

&lt;p&gt;When the user-mode code tries to access an invalid address or one for which it has no permissions, the processors traps into kernel with information about the attempted operation. If the fault is fixable, the kernel fix it and the instruction is restarted. A fixable fault can be an extendible user stack, where the kernel allocates on demand. The kernel must carefully verify the address passed by the user correctly.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;https://pdos.csail.mit.edu/6.828/2018/labs/lab3/#Handling-Interrupts-and-Exceptions&lt;/p&gt;</content><author><name>Yue Yin</name></author><category term="OS" /><summary type="html">Note: this post is largely based on MIT 6.828 Lab3. Thus, we use the term “user environment” instead of the more traditional term “process”. The two are conceptually the same, but differs in interfaces and semantics. User Environment Basics The kernel keeps track of user environments with three data structures: struct Env *envs, struct Env *env_free_list, and struct Env* curenv. envs is allocated at boot time, and env_free_list is initialized based on envs. Environment state: struct Env { struct Trapframe env_tf; // Saved registers when being descheduled struct Env *env_link; // Next free Env envid_t env_id; // Unique environment identifier of the env using this `struct Env` envid_t env_parent_id; // env_id of this env's parent enum EnvType env_type; // Indicates special system environments unsigned env_status; // Status of the environment uint32_t env_runs; // Number of times environment has run // Address space pde_t *env_pgdir; // Kernel virtual address of page dir }; To run a environment, the kernel need logic+data. Logic is primarily defined by env_tf, containing %esp, %eip, etc. Data is defined by the page directory and page tables. To create and run an evironment, call env_create and env_run. Pseudo-code: env_alloc() { env = find from free list; initialize env; } env_setup_vm(e) { e-&amp;gt;env_pgdir = page_alloc(); // allocate page directory e-&amp;gt;env_pgdir = memcpy(kern_pgdir); // copy from kernel's page directory } load_icode(e) { switch from kern_pgdir to e-&amp;gt;env_pgdir; load program data into e's address space using memset, memcpy; switch from e-&amp;gt;env_pgdir to kern_pgdir; allocate user stack for e; set up e-&amp;gt;env_tf; } env_create() { e = env_alloc(); env_setup_vm(e); load_icode(e); } env_pop_tf(e) { pop e-&amp;gt;env_tf into registers; } env_run(e) { switch from kern_pgdir to e-&amp;gt;env_pgdir; env_pop_tf(e); } Protected Control Transfer Exceptions and interrupts are both protected control transfers, causing CPU to switch from user mode (CPL=3) to kernel mode (CPL=0), without giving the user-mode code any opportunity to interfere the kernel or other environments. An interrupt is caused by asynchronous event, like I/O activities. An exception is caused synchronously by currently running code, like division by zero and invalid memory access. Each interrupt/exception is identified by a number in 0-255 (called vector). To ensure protection, entry-points to the kernel are strictly limited. On x86, two mechanisms work together: When interrupt/exception happens, the CPU uses the vector as an index into the interrupt descriptor table (IDT), which was set up in the kernel-private memory. From the IDT entry, the CPU loads %eip (instruction pointer) and %cs (code segment), and starts executing in kernel mode. The CPU needs to save the old processor state before the interrupt/exception occurred, for future resumption. This place must be protected from the user-mode code and the kernel stack can be used. When the interrupt/exception cause a privilege change from user the kernel mode, the CPU reads the kernel stack location (segment selector and address) from the task state segment (TSS). The CPU pushes %ss, %esp, %eflags, %cs, %esp and an optional error code to the kernel stack. Then it loads %cs and %esp from the IDT entry, and sets %ss and %esp to refer to the kernel stack. When an interrupt/exception happens in kernel mode, no stack-switching happens. The CPU just pushes %eflags, %cs, %esp, and an optional error code. This supports nested exception. The kernel should set up the IDT at boot time. Let’s review the responsibility of software and hardware. When an interrupt/exception happens: The hardware reads from TSS to know the position of the kernel stack; The hardware saves %ss, %esp, %cs, %eip, and possibly an error code to the kernel stack, and updates %ss and %esp to refer to the kernel stack. This constructs part of the struct Trapframe. Hardware finishes all its jobs, and software takes over. Control passes to the entry point in trapentry.S, pushes other registers onto the kernel stack to complete the struct Trapframe. Then calls trap, with the trapframe as an argument, in _alltraps. The trap function in trap.c executes. In JOS, trap calls trap_dispatch to dispatch to specific handler. After that trap calls env_run to pop registers and fall back into user mode. Exception Handling System calls can be implemented with protected control transfer. The application pass the system call number and arguments in registers, then calls int $0x30. The kernel passes the return value in %eax. When the user-mode code tries to access an invalid address or one for which it has no permissions, the processors traps into kernel with information about the attempted operation. If the fault is fixable, the kernel fix it and the instruction is restarted. A fixable fault can be an extendible user stack, where the kernel allocates on demand. The kernel must carefully verify the address passed by the user correctly. Reference https://pdos.csail.mit.edu/6.828/2018/labs/lab3/#Handling-Interrupts-and-Exceptions</summary></entry><entry><title type="html">[4] Preemptive Multitasking</title><link href="/os/4-preemptive-multitasking/" rel="alternate" type="text/html" title="[4] Preemptive Multitasking" /><published>2021-04-20T00:00:00+08:00</published><updated>2021-04-20T00:00:00+08:00</updated><id>/os/%5B4%5D-preemptive-multitasking</id><content type="html" xml:base="/os/4-preemptive-multitasking/">&lt;h2 id=&quot;multiprocessor-support&quot;&gt;Multiprocessor support&lt;/h2&gt;

&lt;p&gt;All details explained &lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/labs/lab4/#Part-A--Multiprocessor-Support-and-Cooperative-Multitasking&quot;&gt;here&lt;/a&gt;. Not too important for interview though.&lt;/p&gt;

&lt;p&gt;Per-CPU state:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Per-CPU kernel stack: As multiple CPUs can trap into the kernel simultaneously, a separate kernel stack is needed for each CPU;&lt;/li&gt;
  &lt;li&gt;Per-CPU TSS and TSS descriptor: due to the fact that per-CPU kernel stack exists;&lt;/li&gt;
  &lt;li&gt;Per-CPU current environment pointer;&lt;/li&gt;
  &lt;li&gt;Per-CPU system registers. All registers are private to a CPU, so instructions to initialize the registers, like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lcr3&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lgdt&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lidt&lt;/code&gt; must be excuted once on each CPU.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Definition in JOS:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CpuInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                 &lt;span class=&quot;c1&quot;&gt;// Local APIC ID; index into cpus[] array&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// The status of the CPU&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Env&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpu_env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// The currently-running environment.&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Taskstate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_ts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// TSS Used by x86 to find stack for interrupt&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Locking is required to avoid race conditions. JOS uses a &lt;em&gt;big kernel lock&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;cooperative-multitasking&quot;&gt;Cooperative Multitasking&lt;/h2&gt;

&lt;p&gt;The kernel provides the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_yield&lt;/code&gt; system call for user-mode program. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sys_yield&lt;/code&gt; calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched_yeild&lt;/code&gt;, which searches another runnable env in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;envs&lt;/code&gt;, and call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_run&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;environment-creation-dumbfork&quot;&gt;Environment Creation: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dumbfork&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dumbfork&lt;/code&gt; is an inefficient implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt;: it &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_alloc&lt;/code&gt; an environment (set up the kernel part of the address space), and copies the parent’s register set into the child environment; then it calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;duppage&lt;/code&gt; to copy user part of the address space into the child; then it marks child as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENV_RUNNABLE&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;copy-on-write-fork&quot;&gt;Copy-on-Write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Naive &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt; copies the entire address space, which is inefficient. Later versions of Unix used virtual memory hardware to allow the parent and child to &lt;em&gt;share&lt;/em&gt; the memory mapped into their own address spaces until one of the processes modifies it. This technique is known as &lt;em&gt;copy-on-write&lt;/em&gt;. To do this, on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; the kernel would copy the address space &lt;em&gt;mappings&lt;/em&gt; from the parent to the child instead of the contents of the mapped pages, and mark the now-shared pages read-only. When one of the two processes tries to write to one of these shared pages, the process takes a page fault. At this point, the Unix kernel realizes that the page was really a “copy-on-write” copy, and so it makes a new, private, writable copy of the page for the faulting process. In this way, the contents of individual pages aren’t actually copied until they are actually written to. This optimization makes a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork()&lt;/code&gt; followed by an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; in the child much cheaper: the child will probably only need to copy one page (the current page of its stack) before it calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Copy-on-write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt; is only one of many uses for handling user-level page fault. The kernel can decide what actions to take when getting a user-level page fault in different memory region. For example, A fault in the stack region will allocate and map new page of physical memory. A fault in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bss&lt;/code&gt; region will typically allocate a new page, fill it with zeroes, and map it. In systems with demand-paged executables, a fault in the text region will read a page of the binary off of disk and then map it.&lt;/p&gt;

&lt;p&gt;The exact implementation in JOS is quite complicated (JOS implements user-level &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt;, so page fault handler is implemented in the user code and registered into kernel; the user-level handler needs to consule the page table, so UVPT trick must be used; user stack and user exception stack are needed), but here is the idea for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt; implementation.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_create&lt;/code&gt; to create a new env. This copies the mapping for the kernel part of the address space;&lt;/li&gt;
  &lt;li&gt;Copy the register set of the parent into the child;&lt;/li&gt;
  &lt;li&gt;For each writable or copy-on-write page in the user part of the address space, map the page as copy-on-write into the child’s address space. Note this only copies the mapping, not the physical content;&lt;/li&gt;
  &lt;li&gt;Mark the child runnable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When a page fault happens, the page fault handler does the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Check that the fault is caused by a write AND the page is marked as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COW&lt;/code&gt;. Otherwise, kill the user process.&lt;/li&gt;
  &lt;li&gt;Allocate a new page mapped at a temporay location and copy the contents of the faulting page into it. Then map the new page at the appropritate address with read/write permission, in place of theold read-only mapping.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;preemptive-multitasking&quot;&gt;Preemptive Multitasking&lt;/h2&gt;

&lt;p&gt;To &lt;em&gt;preempt&lt;/em&gt; a running environment, the kernel forcelly retakes control of the CPU by external hardware interrupt from the clock hardware. The user environments must run with interrupts enabled. At boot, set up periodic clock interrupts. In this way, clock interrupts periodically preempts the running user environment and allow the kernel to take control.&lt;/p&gt;

&lt;h2 id=&quot;inter-process-communication&quot;&gt;Inter-Process Communication&lt;/h2&gt;

&lt;p&gt;The “messages” that user environments can send to each other using JOS’s IPC mechanism consist of two components: a single 32-bit value, and optionally a single page mapping. Allowing environments to pass page mappings in messages provides an efficient way to transfer more data than will fit into a single 32-bit integer, and also allows environments to set up shared memory arrangements easily. This is implemented by two system calls: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_ipc_recv&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_ipc_try_send&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;sending-and-receiving-messages&quot;&gt;Sending and Receiving Messages&lt;/h3&gt;

&lt;p&gt;To receive a message, an environment calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_ipc_recv&lt;/code&gt;. This system call de-schedules the current environment and does not run it again until a message has been received. When an environment is waiting to receive a message, any other environment can send it a message - not just a particular environment, and not just environments that have a parent/child relationship with the receiving environment.&lt;/p&gt;

&lt;p&gt;To try to send a value, an environment calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_ipc_try_send&lt;/code&gt;. If the named environment is actually receiving (it has called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_ipc_recv&lt;/code&gt; and not gotten a value yet), then the send delivers the message and returns 0. Otherwise the send returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-E_IPC_NOT_RECV&lt;/code&gt; to indicate that the target environment is not currently expecting to receive a value.&lt;/p&gt;

&lt;p&gt;A library function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_recv&lt;/code&gt; in user space will take care of calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_ipc_recv&lt;/code&gt; and then looking up the information about the received values in the current environment’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct Env&lt;/code&gt;. Similarly, a library function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc_send&lt;/code&gt; will take care of repeatedly calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_ipc_try_send&lt;/code&gt; until the send succeeds.&lt;/p&gt;

&lt;h3 id=&quot;transferring-pages&quot;&gt;Transferring Pages&lt;/h3&gt;

&lt;p&gt;When an environment calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_ipc_recv&lt;/code&gt; with a valid &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dstva&lt;/code&gt; parameter (below UTOP), the environment is stating that it is willing to receive a page mapping. If the sender sends a page, then that page should be mapped at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dstva&lt;/code&gt; in the receiver’s address space. If the receiver already had a page mapped at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dstva&lt;/code&gt;, then that previous page is unmapped.&lt;/p&gt;

&lt;p&gt;When an environment calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys_ipc_try_send&lt;/code&gt; with a valid &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;srcva&lt;/code&gt; (below UTOP), it means the sender wants to send the page currently mapped at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;srcva&lt;/code&gt; to the receiver, with permissions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;perm&lt;/code&gt;. After a successful IPC, the sender keeps its original mapping for the page at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;srcva&lt;/code&gt; in its address space, but the receiver also obtains a &lt;strong&gt;mapping&lt;/strong&gt; for this same physical page at the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dstva&lt;/code&gt; originally specified by the receiver, in the receiver’s address space. As a result this page becomes &lt;strong&gt;shared&lt;/strong&gt; between the sender and receiver.&lt;/p&gt;

&lt;p&gt;If either the sender or the receiver does not indicate that a page should be transferred, then no page is transferred. After any IPC the kernel sets the new field &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env_ipc_perm&lt;/code&gt; in the receiver’s Env structure to the permissions of the page received, or zero if no page was received.&lt;/p&gt;

&lt;h2 id=&quot;q--a&quot;&gt;Q &amp;amp; A&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;What are the ways that processes can communicate with each other?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Pipe. See &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIT6.828/homework/hw2/sh.c&lt;/code&gt; to see how the shell executes a shell command. Main logic:&lt;/p&gt;

        &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;runcmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'|'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;cm&quot;&gt;/* Two forks */&lt;/span&gt;
              &lt;span class=&quot;c1&quot;&gt;// Implementation for pipe is explained in the xv6 book Chapter 0.&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;pcmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipecmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        
              &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        
              &lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        
              &lt;span class=&quot;c1&quot;&gt;// left&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;dup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1 -&amp;gt; pipefd[1] now&lt;/span&gt;
        
                  &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        
                  &lt;span class=&quot;n&quot;&gt;runcmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pcmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
              &lt;span class=&quot;c1&quot;&gt;// right&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;dup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0 -&amp;gt; pipefd[0] now&lt;/span&gt;
        
                  &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        
                  &lt;span class=&quot;n&quot;&gt;runcmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pcmd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
              &lt;span class=&quot;c1&quot;&gt;// Important!&lt;/span&gt;
              &lt;span class=&quot;c1&quot;&gt;// Without closing in the parent process, read() in the &lt;/span&gt;
              &lt;span class=&quot;c1&quot;&gt;// right child would never see the end of the file, and&lt;/span&gt;
              &lt;span class=&quot;c1&quot;&gt;// keeps blocking.&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        
              &lt;span class=&quot;n&quot;&gt;waitpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;waitpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;With &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dup&lt;/code&gt;, shell replaces file decriptor 1 in the left command with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pipefd[0]&lt;/code&gt; (write end), and replaces file descriptor 0 in the right command with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pipefd[1]&lt;/code&gt; (end).&lt;/p&gt;

        &lt;p&gt;How is pipe implemented? See &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xv6-public/pipe.c&lt;/code&gt;, it’s essentially a memory buffer. Functions &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pipealloc&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pipeclose&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pipewrite&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;piperead&lt;/code&gt; are defined.&lt;/p&gt;

        &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;#define PIPESIZE 512
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spinlock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PIPESIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// number of bytes read&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nwrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// number of bytes written&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// read fd is still open&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// write fd is still open&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Shared memory: create a memory region accessible by multiple processes. Just like implemented in JOS.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Message Queue: A linked list of messages maintained by the kernel. TODO: Read &lt;a href=&quot;https://www.geeksforgeeks.org/ipc-using-message-queues/&quot;&gt;this&lt;/a&gt;. Should be similar to IPC above.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Semaphore: in CSAPP, semaphore are only used for thread coordination, as all threads of the same process share the same address. However, it can be used for process coordination. It’s essentially by sharing memory: https://stackoverflow.com/questions/13145885/name-and-unnamed-semaphore.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Socket: network.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Signal: “software interrupt”, implemented similar to interrupt/exception. A process can choose how to handle a signal: default handling, custom handling, ignoring.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;In my understanding, all inter-process communication requires sharing memory, either directly or indirectly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fork&lt;/code&gt;ing a child, the open file table is copied. Why file offset is shared between child and parent?&lt;/p&gt;

    &lt;p&gt;Short answer: Copying the file descriptor just increments the reference count. Offset is associated with the file descriptor.&lt;/p&gt;

    &lt;p&gt;Long answer: See definitions in xv6.&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FD_NONE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FD_PIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FD_INODE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// reference count&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    
  &lt;span class=&quot;c1&quot;&gt;// per-process state&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;// Size of process memory (bytes)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pde_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Page table&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Bottom of kernel stack for this process&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;procstate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Process state&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;// Process ID&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// Parent process&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trapframe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Trap frame for current syscall&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// swtch() here to run process&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// If non-zero, sleeping on chan&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;killed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// If non-zero, have been killed&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ofile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOFILE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Open files&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// Current directory&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// Process name (debugging)&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alarmticks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// interval between two calls to handler&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alarmhandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)();&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// alarm handler. If NULL, not set up for alarm().&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevalarmtick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// system tick when prev handler is invoked&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    
  &lt;span class=&quot;c1&quot;&gt;// Create a new process copying p as the parent.&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Sets up stack to return as if from system call.&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Caller must set state of returned proc to RUNNABLE.&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// Allocate process.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// Copy process state from proc.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copyuvm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgdir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;kfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kstack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNUSED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// Clear %eax so that fork returns 0 in the child.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// Copy file descriptors&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOFILE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ofile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ofile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filedup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ofile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// increments ref count&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cwd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;safestrcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curproc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RUNNABLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
  &lt;span class=&quot;c1&quot;&gt;// Increment ref count for file f.&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;filedup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ftable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;filedup&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ftable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Yue Yin</name></author><category term="OS" /><summary type="html">Multiprocessor support</summary></entry><entry><title type="html">[5.2] Query Execution</title><link href="/database/5.2-query-execution/" rel="alternate" type="text/html" title="[5.2] Query Execution" /><published>2021-04-20T00:00:00+08:00</published><updated>2021-04-20T00:00:00+08:00</updated><id>/database/%5B5.2%5D-query-execution</id><content type="html" xml:base="/database/5.2-query-execution/">&lt;h2 id=&quot;tldr&quot;&gt;TLDR&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+--------------------+
| Query Planning     |
+--------------------+
| Operator Execution | &amp;lt;-
+--------------------+
|   Access Methods   |
+--------------------+
|Buffer Pool Manager |
+--------------------+
|   Disk Manager     |
+--------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Processing model (iterator, materialization, vectorization)&lt;/li&gt;
  &lt;li&gt;Access model (sequential scan, index scan)&lt;/li&gt;
  &lt;li&gt;Process model (process per worker, process pool, thread per worker)&lt;/li&gt;
  &lt;li&gt;Inter-query parallelism&lt;/li&gt;
  &lt;li&gt;Intra-query parallelism (intra-operator, inter-operator, bushy)&lt;/li&gt;
  &lt;li&gt;I/O parallelism (multi-disk parallelism, database partitioning, logical partitioning)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;query-plan&quot;&gt;Query Plan&lt;/h2&gt;

&lt;p&gt;The DBMS converts a SQL query into a &lt;em&gt;query plan&lt;/em&gt;, which consists of operators arranged in a tree. Data flows from the leaf to the root. The output of the root node is the query result. &lt;strong&gt;The same query plan can be executed in multiple ways.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;processing-models&quot;&gt;Processing Models&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;processing model&lt;/em&gt; defines how the DBMS executes a query plan. The model can be implemented to invoke operators either from top-to-bottom or from bottom-to-top. Although the top-to-bottom is more common, the bottom-to-top approach can allow tighter control of cache/register in pipelines.&lt;/p&gt;

&lt;h3 id=&quot;iterator-model&quot;&gt;Iterator Model&lt;/h3&gt;

&lt;p&gt;Also known as Volcano or Pipeline model. The most common processing model for row-based DBMS. The iterator model works by implementing a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; function for every operator. Each node in the query plan calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; on its children until the leaf nodes are reached, which start emitting tuples to the upper levels. Each tuple is then processed up the plan tree as far as possible before the next tuple is retrieved. This is useful in disk-based systems because it allows the DBMS to fully use each tuple in memory before the next tuple/page is accessed. Some operators will block until children emit all their tuples (joins, order by). These are called &lt;em&gt;pipeline breakers&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;materialization-model&quot;&gt;Materialization Model&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;materialization model&lt;/em&gt; is a specialization of the iterator model where each operator processes all its input before emitting all at once - the operator &lt;em&gt;materializes&lt;/em&gt; its output as a single result. To avoid scanning tuples wastefully, the DBMS can propagate down information to subsequent operators about how many tuples are needed. Each query plan operator implements an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The materialization model is better for OLTP, where queries access a small number of tuples that can fit into memory completely, and there are fewer function calls than the iterator model. The materialization model is not suitable for OLAP queries with large intermediate results, as the DBMS may have to spill to disk between operators.&lt;/p&gt;

&lt;h3 id=&quot;vectorization-model&quot;&gt;Vectorization Model&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;vectorization model&lt;/em&gt; has each operator implements a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; function that returns a &lt;em&gt;batch&lt;/em&gt; (or vector) of data instead of a single tuple. The vectorization model is ideal of OLAP queries that have to scan a large number of tuples as there are fewer calls to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;access-methods&quot;&gt;Access Methods&lt;/h2&gt;

&lt;p&gt;An &lt;em&gt;access method&lt;/em&gt; is how the DBMS accesses the data in a table. There’re two major approaches: (1) sequential scan; (2) index scan.&lt;/p&gt;

&lt;h3 id=&quot;sequential-scan&quot;&gt;Sequential Scan&lt;/h3&gt;

&lt;p&gt;The sequential scan operator iterates over every page in the table and retrieves it from the buffer pool.&lt;/p&gt;

&lt;h3 id=&quot;index-scan&quot;&gt;Index Scan&lt;/h3&gt;

&lt;p&gt;The goal of &lt;em&gt;index scan&lt;/em&gt; is to pick the index that help find the data most efficiently. Some DBMSs support multi-index scan: the DBMS computes sets of record IDs using each matching index, combine the sets based on the query predicate, retrieve the records, and apply the remaining predicates. The set intersection can be done by bitmaps, hashtables, or Bloom filters.&lt;/p&gt;

&lt;h2 id=&quot;process-models&quot;&gt;Process Models&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;process model&lt;/em&gt; defines how the system supports concurrent requests. There’re three models:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process per worker: fork a process for each request. Relies on OS scheduling and shared-memory.&lt;/li&gt;
  &lt;li&gt;Process pool: save fork cost. Relies on OS scheduling and shared-memory.&lt;/li&gt;
  &lt;li&gt;Thread per worker: multiple worker threads in a single process. The DBMS can manage its own scheduling.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;inter-query-parallelism&quot;&gt;Inter-Query Parallelism&lt;/h2&gt;

&lt;p&gt;In &lt;em&gt;inter-query parallelism&lt;/em&gt;, the DBMS executes different queries concurrently. If the queries are read-only, little coordination is needed. For writing queries, concurrency control is needed. We discuss this topic in a later post.&lt;/p&gt;

&lt;h2 id=&quot;intra-query-parallelism&quot;&gt;Intra-Query Parallelism&lt;/h2&gt;

&lt;p&gt;In &lt;em&gt;intra-query parallelism&lt;/em&gt;, the DBMS executes operators of a single query in parallel. This reduces latency for long-running queries.&lt;/p&gt;

&lt;p&gt;The organization of intra-query parallelism is similar to a &lt;em&gt;producer/consumer&lt;/em&gt; paradigm: each operator consumes data from operators below it, and produces data for operators above it.&lt;/p&gt;

&lt;p&gt;Parallel algorithms exists for every relational operator. DBMS can either have multiple threads access centralized data structure, or use partitioning to divide work up.&lt;/p&gt;

&lt;p&gt;In intra-query parallelism, there’re three types of parallelism: intra-operator, inter-operator, and bushy. They are not mutually exclusive.&lt;/p&gt;

&lt;h3 id=&quot;intra-operator-parallelism-horizontal&quot;&gt;Intra-Operator Parallelism (Horizontal)&lt;/h3&gt;

&lt;h3 id=&quot;inter-operator-parallelism-vertical&quot;&gt;Inter-Operator Parallelism (Vertical)&lt;/h3&gt;

&lt;h3 id=&quot;bushy-parallelism&quot;&gt;Bushy Parallelism&lt;/h3&gt;

&lt;h2 id=&quot;io-parallelism&quot;&gt;I/O Parallelism&lt;/h2&gt;

&lt;p&gt;Parallel execution will not improve performance if the disk is the bottleneck. In this case, we need to split a database across multiple storage devices. There’re three approaches: multi-disk parallelism, database partitioning, and logical partitioning.&lt;/p&gt;

&lt;h3 id=&quot;multi-disk-parallelism&quot;&gt;Multi-disk Parallelism&lt;/h3&gt;

&lt;p&gt;In &lt;em&gt;multi-disk parallelism&lt;/em&gt;, the OS stores the DBMS’s files across multiple storage devices (like RAID). This is transpraent to the DBMS.&lt;/p&gt;

&lt;h3 id=&quot;database-partitioning&quot;&gt;Database Partitioning&lt;/h3&gt;

&lt;p&gt;In &lt;em&gt;database partitioning&lt;/em&gt;, the database is split into disjoint subsets that can be assigned to concrete disks. Some DBMS allow you to specify the disk location of each individua database.&lt;/p&gt;

&lt;h3 id=&quot;logical-partitioning&quot;&gt;Logical Partitioning&lt;/h3&gt;

&lt;p&gt;In &lt;em&gt;logical partitioning&lt;/em&gt;, a single logical table is split into disjoint physical segments, that are stored separately. The partition is transparent to the application. &lt;em&gt;Vertical partitioning&lt;/em&gt; is like a column store. &lt;em&gt;Horizontal partitioning&lt;/em&gt; divides tuples into disjoint segments based on some partitioning keys (hash, range, predicate partitioning, etc).&lt;/p&gt;</content><author><name>Yue Yin</name></author><category term="Database" /><summary type="html">TLDR</summary></entry><entry><title type="html">[2] Virtual Memory</title><link href="/os/2-virtual-memory/" rel="alternate" type="text/html" title="[2] Virtual Memory" /><published>2021-04-18T00:00:00+08:00</published><updated>2021-04-18T00:00:00+08:00</updated><id>/os/%5B2%5D-virtual-memory</id><content type="html" xml:base="/os/2-virtual-memory/">&lt;h2 id=&quot;tldr&quot;&gt;TLDR&lt;/h2&gt;

&lt;p&gt;To set up virtual memory, the kernel does the following (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt; function):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Allocate memory for page directory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Allocates memory for data structures for physical memory (an array &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt; and a free list &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;);&lt;/li&gt;
  &lt;li&gt;Initialize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt; (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_init&lt;/code&gt; function);&lt;/li&gt;
  &lt;li&gt;Define functions related to physical memory (by reading/writing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;);&lt;/li&gt;
  &lt;li&gt;Define functions related to virtual memory (by reading/writing the page tables);&lt;/li&gt;
  &lt;li&gt;Create mappings in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;, kernel stack, and all physical memory;&lt;/li&gt;
  &lt;li&gt;Switch from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;part-1-physical-page-management&quot;&gt;Part 1: Physical Page Management&lt;/h2&gt;

&lt;p&gt;A physical page allocator is needed before implementing the rest of virtual memory. Reason: the page table management code requires allocating physical memory for (1) page directory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;, and (2) the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt; array of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct PageInfo&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;part2-virtual-memory&quot;&gt;Part2: Virtual Memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/yinfredyue/MIT6.828/blob/master/labNotes/lab2/IntelManualReading%20-%20Chapter%205.md&quot;&gt;Segmentation and paging mechanism&lt;/a&gt;. In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot/boot.S&lt;/code&gt;, segmentation is effectively disabled by setting all segment base addresses to 0 and limits to 0xFFFFFFFF. JOS uses two-level page table.&lt;/p&gt;

&lt;p&gt;Before entering kernel (Lab1), a simple page table maps both virtual address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0x00000000, 0x00400000]&lt;/code&gt; and virtual address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0xf0000000, 0xf0400000]&lt;/code&gt; to physical address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0x00000000, 0x00400000]&lt;/code&gt;. In Lab2, JOS maps the first 256MB of physical memory (this is all physical memory that JOS will use) starting at address 0xF00000000 (this contains the 4MB simple mapping in Lab1) and some other regions.&lt;/p&gt;

&lt;p&gt;The bootloader switched from 16-bit mode to 32-bit protected mode. After that, there’s no way to directly use a linear or physical address. &lt;em&gt;All&lt;/em&gt; memory references are interpreted as virtual addresses and translated by MMU (so all C pointers are virtual addresses). It’s meaningless to dereference a physical address now, as MMU translates all addresses.&lt;/p&gt;

&lt;p&gt;The JOS kernel may need to find a physical address given a virtual address. Kernel global variables and memory allocated by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_alloc&lt;/code&gt; is in the region where the kernel is loaded, starting at 0xF0000000. This is the same address where we mapped ALL physical memory. Thus, to turn a virtual address in this region into a physical address, the kernel can simply subtract 0xF0000000. Use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PADDR(va)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KADDR(pa)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One physical page can be mapped at multiple virtual address (or in the address spaces of multiple environments). The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PageInfo&lt;/code&gt; struct maintains a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp_ref&lt;/code&gt; as the physical page reference count. The value should equal to the number of times the physical page appears &lt;em&gt;below&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTOP&lt;/code&gt; in all page tables (the mappings above &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTOP&lt;/code&gt; are mostly set up at boot time by the kernel and should never be freed, so there’s no need to reference count them).&lt;/p&gt;

&lt;h2 id=&quot;part-3-kernel-address-space&quot;&gt;Part 3: Kernel Address Space&lt;/h2&gt;

&lt;p&gt;JOS divides CPU’s 32-bit address space into two parts. User environments (processes) controls the lower part, while the kernel maintains complete control over the upper half. The dividing line is defined arbitrarily by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ULIM&lt;/code&gt;, reserving approximately 256MB of virtual address space for kernel. Refer to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inc/memlayout.h&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inc/memlayout.h&lt;/code&gt;, kernel and user memory are both present in each environment’s address space, we must set permission bits in page tables properly. Otherwise, bugs in user code can overwrite kernel data.&lt;/p&gt;

&lt;p&gt;For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ULIM, 0xFFFFFFFF]&lt;/code&gt;, the user environment has no permission, while kernel has full permission. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[UTOP, ULIM)&lt;/code&gt;, both the kernel and user environment can read but not write. This range is used to expose certain kernel data structures read-only to the user environment. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0, UTOP)&lt;/code&gt;, the address space is for the user environment to use; the user environment will set permissions for accessing this memory.&lt;/p&gt;

&lt;p&gt;In this part, we set up address space above &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTOP&lt;/code&gt;: the kernel part of the address space. In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_map_region&lt;/code&gt; to map &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt; at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPAGES&lt;/code&gt;, kernel stack at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KSTACKTOP-KSTKSIZE&lt;/code&gt;, and 256MB of physical memory at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KERNBASE&lt;/code&gt;. Because of this, JOS can use at most 256MB of physical memory!&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Part 1 allocates space for data structures (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;) and provides functions to manage physical memory, mainly by manipulating two data structures: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page_free_list&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Part 2 provides functions to manage virtual memory, by manipulating physical memory (using functions in Part 1) and page table.&lt;/p&gt;

&lt;p&gt;Part 3 creates several mappings above &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTOP&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;: maps &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt; into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTOP&lt;/code&gt; (so that user can read some of kernel’s data structure), sets up kernel stack, and maps physical memory into kernel’s address space. Then kernel switches from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;. The virtual memory system is set up now.&lt;/p&gt;

&lt;h2 id=&quot;q--a&quot;&gt;Q &amp;amp; A&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;After paging is enabled, how does the kernel access the page directory &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;?&lt;/p&gt;

    &lt;p&gt;After the bootloader switched from 16-bit mode to 32-bit protected mode, all memory references are interpreted as virtual addresses and get translated by MMU. So the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt; variable represents a virtual address.&lt;/p&gt;

    &lt;p&gt;At entering kernel code, paging uses the page table &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt;, which maps virtual address range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[KERNBASE, KERNBASE+4MB)&lt;/code&gt; at physical address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0, 4MB)&lt;/code&gt;. When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt; is allocated by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot_alloc&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;, it is in the range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[KERNBASE, KERNBASE+4MB)&lt;/code&gt;, covered by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt;. Thus, when paging uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt;, it can access &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt; as the mapping exists in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;When setting up virtual memory, kernel switches from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;. Before switching, kernel must set up mapping in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt; properly. In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt;, the virtual range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[KERNBASE, 2^32)&lt;/code&gt; is mapped at physical range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0, 2^32 - KERNBASE)&lt;/code&gt; - all physical memory is mapped above &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KERNBASE&lt;/code&gt;. Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt; maps &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[KERNBASE, KERNBASE+4MB)&lt;/code&gt; (memory storing kernel code and kernel data structures like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pages&lt;/code&gt;) the same way as in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt;, After switching from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt;, the program still executes correctly and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt; can be accessed correctly.&lt;/p&gt;

    &lt;p&gt;The switching is done in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mem_init&lt;/code&gt; by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lcr3(PADDR(kern_pgdir));&lt;/code&gt;. The physical address of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern_pgdir&lt;/code&gt; is stored into %cr3, to be used by the address translation hardware (MMU).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;https://github.com/yinfredyue/MIT6.828/blob/master/labNotes/lab2/lab2.md&lt;/p&gt;

&lt;p&gt;https://pdos.csail.mit.edu/6.828/2018/labs/lab2/&lt;/p&gt;</content><author><name>Yue Yin</name></author><category term="OS" /><summary type="html">TLDR To set up virtual memory, the kernel does the following (the mem_init function): Allocate memory for page directory kern_pgdir; Allocates memory for data structures for physical memory (an array pages and a free list page_free_list); Initialize pages and page_free_list (the page_init function); Define functions related to physical memory (by reading/writing pages and page_free_list); Define functions related to virtual memory (by reading/writing the page tables); Create mappings in kern_pgdir for pages, kernel stack, and all physical memory; Switch from entry_pgdir to kern_pgdir. Part 1: Physical Page Management A physical page allocator is needed before implementing the rest of virtual memory. Reason: the page table management code requires allocating physical memory for (1) page directory kern_pgdir, and (2) the pages array of struct PageInfo. Part2: Virtual Memory Segmentation and paging mechanism. In boot/boot.S, segmentation is effectively disabled by setting all segment base addresses to 0 and limits to 0xFFFFFFFF. JOS uses two-level page table. Before entering kernel (Lab1), a simple page table maps both virtual address [0x00000000, 0x00400000] and virtual address [0xf0000000, 0xf0400000] to physical address [0x00000000, 0x00400000]. In Lab2, JOS maps the first 256MB of physical memory (this is all physical memory that JOS will use) starting at address 0xF00000000 (this contains the 4MB simple mapping in Lab1) and some other regions. The bootloader switched from 16-bit mode to 32-bit protected mode. After that, there’s no way to directly use a linear or physical address. All memory references are interpreted as virtual addresses and translated by MMU (so all C pointers are virtual addresses). It’s meaningless to dereference a physical address now, as MMU translates all addresses. The JOS kernel may need to find a physical address given a virtual address. Kernel global variables and memory allocated by boot_alloc is in the region where the kernel is loaded, starting at 0xF0000000. This is the same address where we mapped ALL physical memory. Thus, to turn a virtual address in this region into a physical address, the kernel can simply subtract 0xF0000000. Use PADDR(va) and KADDR(pa). One physical page can be mapped at multiple virtual address (or in the address spaces of multiple environments). The PageInfo struct maintains a pp_ref as the physical page reference count. The value should equal to the number of times the physical page appears below UTOP in all page tables (the mappings above UTOP are mostly set up at boot time by the kernel and should never be freed, so there’s no need to reference count them). Part 3: Kernel Address Space JOS divides CPU’s 32-bit address space into two parts. User environments (processes) controls the lower part, while the kernel maintains complete control over the upper half. The dividing line is defined arbitrarily by ULIM, reserving approximately 256MB of virtual address space for kernel. Refer to inc/memlayout.h. As in inc/memlayout.h, kernel and user memory are both present in each environment’s address space, we must set permission bits in page tables properly. Otherwise, bugs in user code can overwrite kernel data. For [ULIM, 0xFFFFFFFF], the user environment has no permission, while kernel has full permission. For [UTOP, ULIM), both the kernel and user environment can read but not write. This range is used to expose certain kernel data structures read-only to the user environment. For [0, UTOP), the address space is for the user environment to use; the user environment will set permissions for accessing this memory. In this part, we set up address space above UTOP: the kernel part of the address space. In mem_init, use boot_map_region to map pages at UPAGES, kernel stack at KSTACKTOP-KSTKSIZE, and 256MB of physical memory at KERNBASE. Because of this, JOS can use at most 256MB of physical memory! Summary Part 1 allocates space for data structures (kern_pgdir, pages, and page_free_list) and provides functions to manage physical memory, mainly by manipulating two data structures: pages and page_free_list. Part 2 provides functions to manage virtual memory, by manipulating physical memory (using functions in Part 1) and page table. Part 3 creates several mappings above UTOP in kern_pgdir: maps pages into UTOP (so that user can read some of kernel’s data structure), sets up kernel stack, and maps physical memory into kernel’s address space. Then kernel switches from entry_pgdir to kern_pgdir. The virtual memory system is set up now. Q &amp;amp; A After paging is enabled, how does the kernel access the page directory kern_pgdir? After the bootloader switched from 16-bit mode to 32-bit protected mode, all memory references are interpreted as virtual addresses and get translated by MMU. So the kern_pgdir variable represents a virtual address. At entering kernel code, paging uses the page table entry_pgdir, which maps virtual address range [KERNBASE, KERNBASE+4MB) at physical address [0, 4MB). When kern_pgdir is allocated by boot_alloc in mem_init, it is in the range [KERNBASE, KERNBASE+4MB), covered by entry_pgdir. Thus, when paging uses entry_pgdir, it can access kern_pgdir as the mapping exists in entry_pgdir. When setting up virtual memory, kernel switches from entry_pgdir to kern_pgdir. Before switching, kernel must set up mapping in kern_pgdir properly. In mem_init, the virtual range [KERNBASE, 2^32) is mapped at physical range [0, 2^32 - KERNBASE) - all physical memory is mapped above KERNBASE. Because kern_pgdir maps [KERNBASE, KERNBASE+4MB) (memory storing kernel code and kernel data structures like kern_pgdir and pages) the same way as in entry_pgdir, After switching from entry_pgdir to kern_pgdir, the program still executes correctly and kern_pgdir can be accessed correctly. The switching is done in mem_init by lcr3(PADDR(kern_pgdir));. The physical address of kern_pgdir is stored into %cr3, to be used by the address translation hardware (MMU). Reference https://github.com/yinfredyue/MIT6.828/blob/master/labNotes/lab2/lab2.md https://pdos.csail.mit.edu/6.828/2018/labs/lab2/</summary></entry><entry><title type="html">[1] Os Bootstrap</title><link href="/os/1-OS-bootstrap/" rel="alternate" type="text/html" title="[1] Os Bootstrap" /><published>2021-04-16T00:00:00+08:00</published><updated>2021-04-16T00:00:00+08:00</updated><id>/os/%5B1%5D-OS-bootstrap</id><content type="html" xml:base="/os/1-OS-bootstrap/">&lt;h1 id=&quot;pc-booting&quot;&gt;PC Booting&lt;/h1&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TLDR&lt;/h2&gt;

&lt;p&gt;When booting a PC, the following happens:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BIOS ROM executes to load &lt;em&gt;bootloader&lt;/em&gt; from &lt;em&gt;boot sector&lt;/em&gt; on disk into memory;&lt;/li&gt;
  &lt;li&gt;The bootloader switches from 16-bit real mode to 32-bit protected mode, and loads kernel code (in ELF format) from disk into memory;&lt;/li&gt;
  &lt;li&gt;The kernel sets up hardware-supported virtual memory, switches to use virtual memory by setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRO_PG&lt;/code&gt; flag in %cr0 register, prepares kernel stack, and jumps to C code at high address.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pc-physical-memory-layout&quot;&gt;PC Physical Memory Layout&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+------------------+  &amp;lt;- 0xFFFFFFFF (4GB)
|      32-bit      |
|  memory mapped   |
|     devices      |
/\/\/\/\/\/\/\/\/\/\

/\/\/\/\/\/\/\/\/\/\
|      Unused      |
+------------------+  &amp;lt;- depends on amount of RAM
|                  |
| Extended Memory  |
|                  |
+------------------+  &amp;lt;- 0x00100000 (1MB)
|     BIOS ROM     |
+------------------+  &amp;lt;- 0x000F0000 (960KB)
|  16-bit devices, |
|  expansion ROMs  |
+------------------+  &amp;lt;- 0x000C0000 (768KB)
|   VGA Display    |
+------------------+  &amp;lt;- 0x000A0000 (640KB)
|    Low Memory    |
+------------------+  &amp;lt;- 0x00000000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Intel 8088 can only address 1MB of physical memory, from 0x00000000 to 0x0000FFFF. The 640KB area marked as “Low Memory” is the only RAM that can be used. The 384KB area from 0x000A0000 through 0x000FFFFF was reserved by the hardware. BIOS is stored in read-only memory (ROM).&lt;/p&gt;

&lt;p&gt;When Intel advanced from 8088 to 8086, the architecture is preserved for backward compatibility. So there’s a “hole” in modern 8086 PC’s physical memory, from 0x000A0000 to 0x00100000. Memory above 0x00100000 is called “extended memory”. Also, some memory at the top of the 32-bit address space is also reserved. If the processor can support more than 4GB of physical memory, this becomes the second “hole” in the physical memory address space. JOS only uses the first 256 MB of a PC’s physical memory.&lt;/p&gt;

&lt;h2 id=&quot;bios-rom&quot;&gt;BIOS ROM&lt;/h2&gt;

&lt;p&gt;BIOS loads bootloader from disk into memory. If the disk is bootable, the first sector is called the &lt;em&gt;boot sector&lt;/em&gt;. BIOS loads the boot sector into memory at physical address 0x7c00 through 0x7dff, and uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp&lt;/code&gt; instruction to set the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CS:IP&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0000:7c00&lt;/code&gt;, passing control to the boot loader. Theses addresses are designed arbitrarily by Intel.&lt;/p&gt;

&lt;h2 id=&quot;bootloader&quot;&gt;Bootloader&lt;/h2&gt;

&lt;p&gt;The bootloader loads the kernel from disk. The kernel is stored starting from the 2nd disk sector, in ELF format.&lt;/p&gt;

&lt;p&gt;When compiling and linking a C program, the compiler transforms source file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.c&lt;/code&gt; into &lt;em&gt;object file&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.o&lt;/code&gt;. The object file contains assembly instructions in binary format (0’s and 1’s). The linker combines all object files into a single &lt;em&gt;binary image&lt;/em&gt; like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj/kern/kernel&lt;/code&gt; in the ELF format. ELF: Executable and Linkable Format.&lt;/p&gt;

&lt;p&gt;Consider an ELF executable as a header with loading information, followed by several &lt;em&gt;program sections&lt;/em&gt;, each being a contiguous chunk of code or data to be loaded at a specified memory address. The boot loader loads the ELF executable into memory and starts executing.&lt;/p&gt;

&lt;p&gt;An ELF binary starts with a fixed-length &lt;em&gt;ELF header&lt;/em&gt;, followed by a variable-length &lt;em&gt;program header&lt;/em&gt;, listing program sections to be loaded. We are interested in the following program sections:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.text&lt;/code&gt;: the program’s executable instructions.&lt;/li&gt;
  &lt;li&gt;.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rodata&lt;/code&gt;: read-only data, like ASCII string constants produced by the C compiler.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.data&lt;/code&gt;: the program’s initialized data, like &lt;em&gt;initialized&lt;/em&gt; global variables.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bss&lt;/code&gt;: space for &lt;em&gt;uninitialized&lt;/em&gt; global variables, the space is zeroed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When linker computes the memory layout of the program, it reserves space for &lt;em&gt;unitialized&lt;/em&gt; global variables in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bss&lt;/code&gt; section, immediately after &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.data&lt;/code&gt;. C requires that unitialized global variables start with value of zero. There’s no need to store contents for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bss&lt;/code&gt; in the ELF binary. Instead, the linker records the address and size of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bss&lt;/code&gt; section. The loader arranges to zero the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bss&lt;/code&gt; section when loading the executable into the memory.&lt;/p&gt;

&lt;h2 id=&quot;kernel&quot;&gt;Kernel&lt;/h2&gt;

&lt;p&gt;LMA, load memory address, is the memory address at which that section should be loaded into memory. VMA, virtual memory address, is the memory address from which the section expects to execute. For example, JOS kernel has VMA = 0xf0100000, LMA = 0x00100000.&lt;/p&gt;

&lt;p&gt;The kernel is loaded at high virtual address to leave the lower part of the address space to user programs. At bootstrap, PC relies on CPU’s memory management hardware to map high virtual address to low physical address. For JOS, we’ll map the first 4MB of physical memory, from physical address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00000000&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00400000&lt;/code&gt;, to virtual addresses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xf0000000&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xf0400000&lt;/code&gt;. This is done using hand-written, statically-initialized page directory and page table in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern/entrypgdir.c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Up until the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CR0_PG&lt;/code&gt; is set, memory references are treated as physical addresses. Once &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CR0_PG&lt;/code&gt; is set, memory references are virtual addresses translated by the virtual memory hardware to physical addresses. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry_pgdir&lt;/code&gt; translates virtual addresses in the range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xf0000000&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xf0400000&lt;/code&gt; to physical addresses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00000000&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00400000&lt;/code&gt;, as well as virtual addresses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00000000&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00400000&lt;/code&gt; to physical addresses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00000000&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00400000&lt;/code&gt;. That is, both virtual address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0x00000000, 0x00400000]&lt;/code&gt; and virtual address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0xf0000000, 0xf0400000]&lt;/code&gt; are mapped to physical address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0x00000000, 0x00400000]&lt;/code&gt;. Any virtual address that’s not in one of these two ranges would cause hardware exception.&lt;/p&gt;

&lt;h2 id=&quot;kernel-stack&quot;&gt;Kernel stack&lt;/h2&gt;

&lt;p&gt;The kernel stack is manually allocated using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.data&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.data
###################################################################
# boot stack
###################################################################
	.p2align	PGSHIFT		# force page alignment
	.globl		bootstack
bootstack:
	.space		KSTKSIZE
	.globl		bootstacktop   
bootstacktop:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;https://github.com/yinfredyue/MIT6.828/blob/master/labNotes/lab1/lab1.md&lt;/p&gt;

&lt;p&gt;https://pdos.csail.mit.edu/6.828/2018/labs/lab1/&lt;/p&gt;</content><author><name>Yue Yin</name></author><category term="OS" /><summary type="html">PC Booting</summary></entry></feed>